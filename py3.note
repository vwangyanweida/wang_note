1、if is_py3:
      def u(s):
        return s
   else:
      def u(s):
        return s.decode('unicode-escape')
可以让一个函数根据情况自动选择适当的定义。

2、初始化一个类时，如果类的初始化函数定义的格式def __init__（a = 1,b = 2,c = 3,d =4 ）格式时，若参数是列表需要加一个* ,若是字典时需要加**表示。
3、函数加默认值时，有默认值的参数必须在没有默认值参数的后面，如:def a(a,b,c=1,d=2)，这样，顺序不能乱，赋值时可以都用列表，也可以都用字典，如: a(1,3,*[3,4]),a(**{"a":1,"b":2,"c":3,"d":4}),a(1,2,*[3],**{"d":4})
4、类函数中定义的函数如果有self说明时类实例函数，需要实例对象以后由对象调用，如果类中函数第一个参数时cls，用@classmethod修饰器修饰，说明时类方法。

注意：@classmethod 仅仅适用于单独的，与类本身的数据结构无关函数，其实用了它的函数，与使用普通函数无异，甚至不能在参数里加入 self，如果要在其中使用类的数据结构，仍然需要将类实例化一次才可以，所以要小心使用。classmethod修饰的函数第一个参数应该是cls，即调用类为第一个参数，而不能为空。
5、enumerate接受列表或数组。
def enumerate (collection ): 
  'Generates an indexed series:  (0,coll[0]), (1,coll[1]) ...'       
  i = 0 
  it = iter (collection ) 
  while 1 : 
       yield (i , it . next ()) 
       i += 1 

6、要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：
    eg.  g = (x * x for x in range(10))
         g
         <generator object <genexpr> at 0x11...>
7、yield生成器函数:函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。

8、如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问,需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。
有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。
双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量：

9、字典推导
my_phrase = ["No", "one", "expects", "the", "Spanish", "Inquisition"]
my_dict = {key: value for value, key in enumerate(my_phrase)}
print(my_dict)
reversed_dict = {value: key for key, value in my_dict.items()}
print(reversed_dict)

10.高阶函数：
    map
    from functools import reduce，reduce
    filter
    sorted：它可以接受一个key函数来实现自定义的排序，key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。

11.闭包
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum

f = lazy_sum(1,2,3,4,5)
f
<function lazy_sum.<locals>.sum at0x0101ad>
在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力

12.@coroutine decorator的定义如下

def coroutine(func):
    def start(*args,**kwargs):
        cr = func(*args,**kwargs)
        cr.next()
        return cr
    return start

这是因为需要使用yield，但可能忘记第一次初始化，next(target)或者target.send(None),所以写来这个装饰器，将yield的第一次next加上。

import time
from tornado.gen import coroutine

def follow(thefile,target):
    thefile.seek(0,2)   #go to the end of the file
    while True:
        line = thefile.readline()
        if not line:
            time.sleep(0.1)
            continue
        target.send(line)

@coroutine
def printer():
    while True:
        line = (yield)
        print(line)

if __name__ == '__main__':
    f = open("t.txt")                                                           
    follow(f,printer())

协程使用的就是yield关键字方法，像一个生成器。


13.__slots__ 方法:限制实例的属性
    eg.     
        class Student(object):
            __slots__ = ('name','age') #用tuple定义允许绑定的属性名称。

    1>注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。子类如果需要，可以重新定义__slots__.

14.@property
    
    eg.
        class Student(object):

            @property
            def score(self):
                return self._score

            @score.setter
            def score(self, value):
                if not isinstance(value, int):
                    raise ValueError('score must be an integer!')
                if value < 0 or value > 100:
                    raise ValueError('score must between 0 ~ 100!')
                self._score = value

    1> Python内置的@property装饰器就是负责把一个方法变成属性调用的
    
   2>  把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作
        
    s = Student()
    s.score = 60
    s.score
>>> 60

15.
    elf, name='world'): # 先定义函数
                          ...     print('Hello, %s.' % name)ype()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过type()函数创建出Hello类，而无需通过class Hello(object)...的定义
    
    通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。
    eg.

    >>> def fn(self, name='world'): # 先定义函数
    ...     print('Hello, %s.' % name)
            Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
            h = Hello()
            h.hello()
    Hello, world

    要创建一个class对象，type()函数依次传入3个参数：

    1.class的名称；
    2.继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；
    3.class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。
