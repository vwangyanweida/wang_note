一、状态模式：
    把每一个状态判断分支写成一个类，跟状态有关的操作写到状态类中。状态类要可以判断状态执行操作或者转到下一个状态，调用操作类的操作方法。

二、UML:
1.类图：
    类图分三层，第一层显示类的名称，如果是抽象类，则用斜体显示。第二层是类的特性，通常是字段和属性。第三层是类的操作，同长是方法或行为。注意前面的符号，'+'表示public，'-'表示为private，'#'表示protected。

2.接口图：与类图最主要额区别是顶端有<<interface>>显示。

3。关系
    继承关系用空心三角形 + 实线来表示。(箭头指向父类)
    实现接口用空心三角形 + 虚线来表示。(箭头指向接口)
    关联关系(当一个类'知道'另一个类时，用关联关系)关联关系用实线箭头表示(箭头指向被关联的对象)
    聚合关系：用空心棱形 +　实现箭头来表示(箭头指向个体，棱形指向聚合类)
    合成(组成)关系，用实心的棱形 + 实线箭头表示(箭头指向组成部分，棱形指向整体)
    依赖关系：用虚线箭头来表示。

三、组合模式
    将对象组合成树形结构以表示'部分-整体'的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。

四、迭代器模式
    提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。
    迭代器模式现在各个语言现在都已经封装到了语言之中了。

五、单例模式
    保证一个类只有一个实例，并提供一个访问它的全局访问点。
    
    最简单的方法是重写new方法。在类的本身里定义一个私有变量instance，new方法中判断这个instanc的值，然后决定是new一个还是直接返回。
    
    如果有多线程时，可以再new的地方加一个锁。但这样每次调用new方法都会加一个锁，解决办法是双重锁定：先判断instance是否为null，如果为null，加锁，然后再次判断instance是否为null，为null，new一个实例。
    有些语言不需要显示的实现线程安全，语言中封装有线程安全。

    第二种方法称为静态初始化方法，在类中声明一个static/readonly私有变量，这个变量直接赋值为一个new的对象。这种静态初始化的方式是在自己被加载时就将自己实例化，所有形象的称之为饿汉式单例类，而第一种的单例模式处理方式是要在第一次被引用时，才会将自己实例化，所以称为懒汉式单例类。这种方法不需要开发人员显示的编写线程安全代码，即可解决线程安全问题。

六、桥接模式
    合成/聚合复用原则。即尽量使用对象合成/聚合，尽量不要使用类继承。
    聚合表示一种弱的'拥有'关系，uml中有，
    合成表示一种强的'拥有'关系....

    合成/聚合复用原则的好处是，优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。

七、中介者模式
    用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
    中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多子类的场合。

八、享元模式
    运用共享技术有效地支持大量细粒度的对象。
