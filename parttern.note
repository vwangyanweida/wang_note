一、状态模式：
    把每一个状态判断分支写成一个类，跟状态有关的操作写到状态类中。状态类要可以判断状态执行操作或者转到下一个状态，调用操作类的操作方法。

二、UML:
1.类图：
    类图分三层，第一层显示类的名称，如果是抽象类，则用斜体显示。第二层是类的特性，通常是字段和属性。第三层是类的操作，同长是方法或行为。注意前面的符号，'+'表示public，'-'表示为private，'#'表示protected。

2.接口图：与类图最主要额区别是顶端有<<interface>>显示。

3。关系
    继承关系用空心三角形 + 实线来表示。(箭头指向父类)
    实现接口用空心三角形 + 虚线来表示。(箭头指向接口)
    关联关系(当一个类'知道'另一个类时，用关联关系)关联关系用实线箭头表示(箭头指向被关联的对象)
    聚合关系：用空心棱形 +　实现箭头来表示(箭头指向个体，棱形指向聚合类)
    合成(组成)关系，用实心的棱形 + 实线箭头表示(箭头指向组成部分，棱形指向整体)
    依赖关系：用虚线箭头来表示。

三、组合模式
    将对象组合成树形结构以表示'部分-整体'的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。

四、迭代器模式
    提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。
    迭代器模式现在各个语言现在都已经封装到了语言之中了。

五、单例模式
    保证一个类只有一个实例，并提供一个访问它的全局访问点。
    
    最简单的方法是重写new方法。在类的本身里定义一个私有变量instance，new方法中判断这个instanc的值，然后决定是new一个还是直接返回。
    
    如果有多线程时，可以再new的地方加一个锁。但这样每次调用new方法都会加一个锁，解决办法是双重锁定：先判断instance是否为null，如果为null，加锁，然后再次判断instance是否为null，为null，new一个实例。
    有些语言不需要显示的实现线程安全，语言中封装有线程安全。

    第二种方法称为静态初始化方法，在类中声明一个static/readonly私有变量，这个变量直接赋值为一个new的对象。这种静态初始化的方式是在自己被加载时就将自己实例化，所有形象的称之为饿汉式单例类，而第一种的单例模式处理方式是要在第一次被引用时，才会将自己实例化，所以称为懒汉式单例类。这种方法不需要开发人员显示的编写线程安全代码，即可解决线程安全问题。

六、桥接模式
    合成/聚合复用原则。即尽量使用对象合成/聚合，尽量不要使用类继承。
    聚合表示一种弱的'拥有'关系，uml中有，
    合成表示一种强的'拥有'关系....

    合成/聚合复用原则的好处是，优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。

七、中介者模式
    用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
    中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多子类的场合。

八、享元模式
    运用共享技术有效地支持大量细粒度的对象。
    
    享元工厂(FlyweighFactory)，用来创建并管理Flyweigh对象。它主要是用来确保合理地共享Flyweigh，当用户请求一个Flywegigh时，FlyweighFactory对象提供一个已创建的实例或者创建一个（如果不存在的话）。
    Flyweigh：所有具体享元类的超类或接口，通过这个接口，Flyweigh可以接受并作用于外部状态。

    内部状态和外部状态
        在享元对象内部并且不会随环境改变而改变的共享部分，可以称为是享元对象的内部状态，而随环境改变而改变的、不可以共享的状态就是外部状态了。

    享元模式可以避免大量非常相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本都是相同的，有时就能够大幅度的减少需要实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度的减少单个实例的数目。

    如果一个应用程序是用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用享元模式；还有就是对象的大多数状态可以是外部，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象，此时可以考虑使用享元模式。

九、解释器模式
    给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

    解释器模式需要解决的是，如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。
