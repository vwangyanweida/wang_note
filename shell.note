1.运行Linux程序有3种方法：
    1>使文件具有可执行权限，直接运行文件；
    2>直接调用命令解释器执行程序
    3>使用source执行命令

2.whereis 查询完整路径

3.Linux shell可执行命令有3种：内建命令、shell函数和外部命令
    1>内建命令就是shell程序本身包含的命令。在执行内建命令时，没有进程的创建和消亡。
    2>shell函数是一系列的程序代码，以shell语言写成
    3>外部命令是独立于shell的可执行程序，例如find、grep、，命令行shell在执行外部命令时，会创建一个当前shell的复制进程来执行，在执行过程中，存在进程的创建和消亡。

    note：只有内建命令才能改变命令行shell的属性设置（环境变量）

4.source file：
    source执行shell脚本时，不会创建子进程，而是在父进程中直接执行！

5.shell不区分变量类型，一切都是字符串，但可以进行比较和整数操作，关键因素是：变量中的字符串值是否为数字。

    变量名＝值，＝号两边不要有任何空格。在名称前加上$符号来获取变量的值。赋值内容包含空格时，请加上引号。$with_space 事实上是${with_space}的简写形式，在可能会引起错误的时候，可以用${with_sapce}。

6.变量不加$的时候，变量可能存在如下几种情况：变量被声明或被赋值；变量被unset；或者变量被export。

7.单双引号：
    被一对双引号括起来的变量替换是不会被阻止的，所以双引号被称为部分引用，也称为“弱引用”，单引号中变量替换就会被禁止，变量名只会被解释成字面意思，不会发生变量替换，所以单引号被称为“全引用”，也称为“强引用”。
    eg
    >>>var=123
    >>>echo '$var'
    $var
    >>>echo "$var"
    123

8.变量值可以是空值（“NULL”），就是不包含任何字符，在算数操作中，这个未初始化的变量常常看起来是0，但这是一个未文档化的行为，并且不可移植。

9.Linux Shell 局部变量必须明确以local声明，否则就是全局可见的。

10.echo 命令的任务就是输出一行文本。

11.如果一个脚本要设置一个环境变量，那么需要将这些变量“export”出来，也就是需要通知到脚本本地的环境。这是export命令的功能。
    一个脚本只能够export变量到这个脚本所产成的子进程，也就是说只能够对这个脚本所产生的命令和和进程起作用。如果脚本是从命令行中调用的，那么这个脚本所export得变量是不能影响命令行环境的。当使用source命令时，因为没有产生子进程，此时export命令将影响父进程的环境。
    expot [-fnp][变量名称]＝[变量设置值]

    export命令设置适用于当前shell的环境变量值。修改后维持不变，直到当前shell消亡，在脚本中执行对父shell进程环境没有影响，如果要吧对环境变量的设置永久保存，可以在export命令置于shell登录时执行的启动文件中。env命令则可以临时改变环境变量值。

11.unset 命令从当前shell中删除函数或变量。删除变量时，使用-v选项（默认情况），删除函数时使用-f选项：
eg  
    >echo $vari
    123
    >unset vari
    >echo $vari
    Null
    >hello() "echo "hello,world!"
    >unset -f hello

12. $#:代表传入函数的参数的个数
    $@:代表所有参数的内容

13.ps aux |grep 'python monitor.py'|cut -c 9-15|xargs kill -9(按名称杀掉改程序)

14.mac改终端中的计算机名：sudo scutil --set HostName rainbird-desk

15.我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……

处理参数的特殊字符：

参数处理    说明
$#  传递到脚本的参数个数
$*  以一个单字符串显示所有向脚本传递的参数
$$  脚本运行的当前进程ID号
$!  后台运行的最后一个进程的ID号
$@  与$*相同，但是使用时加引号，并在引号中返回每个参数。
$-  显示Shell使用的当前选项，与set命令功能相同。
$?  显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。

16.Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。
array_name=(value1 ... valuen)

    读取数组元素值的一般格式是：
    ${array_name[index]}

    使用@ 或 * 可以获取数组中的所有元素，例如：

    获取数组长度的方法与获取字符串长度的方法相同，例如：
    echo "数组元素个数为: ${#my_array[*]}"
    echo "数组元素个数为: ${#my_array[@]}"

17.!!!!!!! shell 数学运算
原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。
expr 是一款表达式计算工具，使用它能完成表达式的求值操作。

表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。
完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。

18.
算术运算符
下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：
运算符  说明    举例
+   加法    `expr $a + $b` 结果为 30。
-   减法    `expr $a - $b` 结果为 10。
*   乘法    `expr $a \* $b` 结果为  200。
乘号(*)前边必须加反斜杠(\)才能实现乘法运算；)
/   除法    `expr $b / $a` 结果为 2。
%   取余    `expr $b % $a` 结果为 0。
=   赋值    a=$b 将把变量 b 的值赋给 a。
==  相等。用于比较两个数字，相同则返回 true。   [ $a == $b  ] 返回 false。
!=  不相等。用于比较两个数字，不相同则返回 true。   [ $a != $b  ] 返回 true。
注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b  ]。
    note:如果没有空格，将作为字符串参与运算。

19.
关系运算符
关系运算符只支持数字，不支持字符串，除非字符串的值是数字。
下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：
运算符  说明    举例
-eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b  ] 返回 false。
-ne 检测两个数是否相等，不相等返回 true。   [ $a -ne $b  ] 返回 true。
-gt 检测左边的数是否大于右边的，如果是，则返回 true。   [ $a -gt $b  ] 返回 false。
-lt 检测左边的数是否小于右边的，如果是，则返回 true。   [ $a -lt $b  ] 返回 true。
-ge 检测左边的数是否大等于右边的，如果是，则返回 true。 [ $a -ge $b  ] 返回 false。
-le 检测左边的数是否小于等于右边的，如果是，则返回 true。   [ $a -le $b  ] 返回 true。

    note:中括号中的判断语句必须和中括号有空格，否则报错

20.
布尔运算符
下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：
运算符  说明    举例
!   非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false  ] 返回 true。
-o  或运算，有一个表达式为 true 则返回 true。   [ $a -lt 20 -o $b -gt 100  ] 返回 true。
-a  与运算，两个表达式都为 true 才返回 true。   [ $a -lt 20 -a $b -gt 100  ] 返回 false。

21.
下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：
运算符  说明    举例
=   检测两个字符串是否相等，相等返回 true。 [ $a = $b  ] 返回 false。
!=  检测两个字符串是否相等，不相等返回 true。   [ $a != $b  ] 返回 true。
-z  检测字符串长度是否为0，为0返回 true。   [ -z $a  ] 返回 false。
-n  检测字符串长度是否为0，不为0返回 true。 [ -z $a  ] 返回 true。
str 检测字符串是否为空，不为空返回 true。   [ $a  ] 返回 true。

22.
文件测试运算符
文件测试运算符用于检测 Unix 文件的各种属性。
属性检测描述如下：
操作符  说明    举例
-b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file  ] 返回 false。
-c file 检测文件是否是字符设备文件，如果是，则返回 true。   [ -b $file  ] 返回 false。
-d file 检测文件是否是目录，如果是，则返回 true。   [ -d $file  ] 返回 false。
-f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file  ] 返回 true。
-g file 检测文件是否设置了 SGID 位，如果是，则返回 true。   [ -g $file  ] 返回 false。
-k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file  ] 返回 false。
-p file 检测文件是否是具名管道，如果是，则返回 true。   [ -p $file  ] 返回 false。
-u file 检测文件是否设置了 SUID 位，如果是，则返回 true。   [ -u $file  ] 返回 false。
-r file 检测文件是否可读，如果是，则返回 true。 [ -r $file  ] 返回 true。
-w file 检测文件是否可写，如果是，则返回 true。 [ -w $file  ] 返回 true。
-x file 检测文件是否可执行，如果是，则返回 true。   [ -x $file  ] 返回 true。
-s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。    [ -s $file  ] 返回 true。
-e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file  ] 返回 true。

